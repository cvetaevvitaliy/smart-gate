# Copyright (c) 2010 - 2020, Nordic Semiconductor ASA
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# 3. Neither the name of Nordic Semiconductor ASA nor the names of its
#    contributors may be used to endorse or promote products derived from this
#    software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

# This file was autogenerated by serial_doc_gen_pyaci.py at 2019-08-29 16:15:17.
from aci.aci_utils import EventPacket, barray_pop
import struct

class CmdRsp(EventPacket):
    """Command response.

    Parameters
    ----------
        opcode : uint8_t
            Opcode of original command.
        status : uint8_t
            Return status of the serial command.
        data : uint8_t[252]
            Optional command response data.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["opcode"], = struct.unpack("<B", raw_data[0:1])
        __data["status"], = struct.unpack("<B", raw_data[1:2])
        __data["data"] = raw_data[2:]
        super(CmdRsp, self).__init__("CmdRsp", 0x84, __data)


class DeviceStarted(EventPacket):
    """The device has started, and is ready for commands.

    Parameters
    ----------
        operating_mode : uint8_t
            Operating mode of the device. see @ref serial_device_operating_mode_t for accepted
            values.
        hw_error : uint8_t
            Hardware error code, or 0 if no error occurred.
        data_credit_available : uint8_t
            The number of bytes available in each of the tx and rx buffers.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["operating_mode"], = struct.unpack("<B", raw_data[0:1])
        __data["hw_error"], = struct.unpack("<B", raw_data[1:2])
        __data["data_credit_available"], = struct.unpack("<B", raw_data[2:3])
        super(DeviceStarted, self).__init__("DeviceStarted", 0x81, __data)


class DeviceEchoRsp(EventPacket):
    """Response to the Echo command.

    Parameters
    ----------
        data : uint8_t[254]
            Data received in the echo command.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["data"] = raw_data[0:]
        super(DeviceEchoRsp, self).__init__("DeviceEchoRsp", 0x82, __data)


class DeviceInternalEvent(EventPacket):
    """Internal stack event occurred.

    Parameters
    ----------
        event_type : uint8_t
            Reported event. See @ref internal_event_type_t for accepted values.
        state : uint8_t
            State information about the event type reported.
        packet_size : uint8_t
            Size (in bytes) of the packet.
        packet : uint8_t[31]
            Event data.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["event_type"], = struct.unpack("<B", raw_data[0:1])
        __data["state"], = struct.unpack("<B", raw_data[1:2])
        __data["packet_size"], = struct.unpack("<B", raw_data[2:3])
        __data["packet"] = raw_data[3:34]
        super(DeviceInternalEvent, self).__init__("DeviceInternalEvent", 0x83, __data)


class Application(EventPacket):
    """Application event, only sent by the device application.

    Parameters
    ----------
        data : uint8_t[254]
            Application data.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["data"] = raw_data[0:]
        super(Application, self).__init__("Application", 0x8A, __data)


class SarStart(EventPacket):
    """Start of a Segmentation and Reassembly message from the device."""
    def __init__(self, raw_data):
        __data = {}
        super(SarStart, self).__init__("SarStart", 0x8B, __data)


class SarContinue(EventPacket):
    """Continuation of a Segmentation and Reassembly message from the device."""
    def __init__(self, raw_data):
        __data = {}
        super(SarContinue, self).__init__("SarContinue", 0x8C, __data)


class DfuReqRelay(EventPacket):
    """Received a request from another device to act as a relay in a DFU transaction.

    Parameters
    ----------
        dfu_type : uint8_t
            DFU type of the transfer. See @ref nrf_mesh_dfu_type_t.
        fwid : nrf_mesh_fwid_t
            Firmware ID of the requested transfer.
        authority : uint8_t
            Authority level of the transfer.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["dfu_type"], = struct.unpack("<B", raw_data[0:1])
        __data["fwid"] = raw_data[1:11]
        __data["authority"], = struct.unpack("<B", raw_data[11:12])
        super(DfuReqRelay, self).__init__("DfuReqRelay", 0xA0, __data)


class DfuReqSource(EventPacket):
    """Recevied a request from another device to act as a source in a DFU transaction.

    Parameters
    ----------
        dfu_type : uint8_t
            DFU type of the transfer. See @ref nrf_mesh_dfu_type_t.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["dfu_type"], = struct.unpack("<B", raw_data[0:1])
        super(DfuReqSource, self).__init__("DfuReqSource", 0xA1, __data)


class DfuStart(EventPacket):
    """The current DFU operation started its data transfer stage.

    Parameters
    ----------
        role : uint8_t
            The device's role in the transfer. See @ref nrf_mesh_dfu_role_t.
        dfu_type : uint8_t
            DFU type of the transfer. See @ref nrf_mesh_dfu_type_t.
        fwid : nrf_mesh_fwid_t
            Firmware ID of the transfer.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["role"], = struct.unpack("<B", raw_data[0:1])
        __data["dfu_type"], = struct.unpack("<B", raw_data[1:2])
        __data["fwid"] = raw_data[2:12]
        super(DfuStart, self).__init__("DfuStart", 0xA2, __data)


class DfuEnd(EventPacket):
    """The current DFU operation ended its data transfer stage.

    Parameters
    ----------
        role : uint8_t
            The device's role in the transfer. See @ref nrf_mesh_dfu_role_t.
        dfu_type : uint8_t
            DFU type of the transfer. See @ref nrf_mesh_dfu_type_t.
        fwid : nrf_mesh_fwid_t
            Firmware ID of the transfer.
        end_reason : uint8_t
            Reason for ending the transfer. See @ref nrf_mesh_dfu_end_t.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["role"], = struct.unpack("<B", raw_data[0:1])
        __data["dfu_type"], = struct.unpack("<B", raw_data[1:2])
        __data["fwid"] = raw_data[2:12]
        __data["end_reason"], = struct.unpack("<B", raw_data[12:13])
        super(DfuEnd, self).__init__("DfuEnd", 0xA3, __data)


class DfuBankAvailable(EventPacket):
    """A DFU firmware bank is available for flashing.

    Parameters
    ----------
        dfu_type : uint8_t
            DFU type of the transfer. See @ref nrf_mesh_dfu_type_t.
        fwid : nrf_mesh_fwid_t
            Firmware ID of the transfer.
        start_addr : uint32_t
            Start address of the bank.
        length : uint32_t
            Length of the banked firmware.
        is_signed : uint8_t
            Whether the bank is signed or not.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["dfu_type"], = struct.unpack("<B", raw_data[0:1])
        __data["fwid"] = raw_data[1:11]
        __data["start_addr"], = struct.unpack("<I", raw_data[11:15])
        __data["length"], = struct.unpack("<I", raw_data[15:19])
        __data["is_signed"], = struct.unpack("<B", raw_data[19:20])
        super(DfuBankAvailable, self).__init__("DfuBankAvailable", 0xA4, __data)


class DfuFirmwareOutdated(EventPacket):
    """The mesh has received a secure notification indicating that the framework is out of date.

    Parameters
    ----------
        dfu_type : uint8_t
            DFU type of the transfer. See @ref nrf_mesh_dfu_type_t.
        available_fwid : nrf_mesh_fwid_t
            Firmware ID of the newest firmware available.
        current_fwid : nrf_mesh_fwid_t
            Firmware ID of the current version of the outdated firmware.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["dfu_type"], = struct.unpack("<B", raw_data[0:1])
        __data["available_fwid"] = raw_data[1:11]
        __data["current_fwid"] = raw_data[11:21]
        super(DfuFirmwareOutdated, self).__init__("DfuFirmwareOutdated", 0xA5, __data)


class DfuFirmwareOutdatedNoAuth(EventPacket):
    """The mesh has received an insecure notification indicating that the framework is out of
    date. Call _Direct Firmware Upgrade Request_ to initiate a request to receive the firmware
    upgrade.

    Parameters
    ----------
        dfu_type : uint8_t
            DFU type of the transfer. See @ref nrf_mesh_dfu_type_t.
        available_fwid : nrf_mesh_fwid_t
            Firmware ID of the newest firmware available.
        current_fwid : nrf_mesh_fwid_t
            Firmware ID of the current version of the outdated firmware.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["dfu_type"], = struct.unpack("<B", raw_data[0:1])
        __data["available_fwid"] = raw_data[1:11]
        __data["current_fwid"] = raw_data[11:21]
        super(DfuFirmwareOutdatedNoAuth, self).__init__("DfuFirmwareOutdatedNoAuth", 0xA6, __data)


class OpenmeshNew(EventPacket):
    """Not implemented."""
    def __init__(self, raw_data):
        __data = {}
        super(OpenmeshNew, self).__init__("OpenmeshNew", 0xB3, __data)


class OpenmeshUpdate(EventPacket):
    """Not implemented."""
    def __init__(self, raw_data):
        __data = {}
        super(OpenmeshUpdate, self).__init__("OpenmeshUpdate", 0xB4, __data)


class OpenmeshConflicting(EventPacket):
    """Not implemented."""
    def __init__(self, raw_data):
        __data = {}
        super(OpenmeshConflicting, self).__init__("OpenmeshConflicting", 0xB5, __data)


class OpenmeshTx(EventPacket):
    """Not implemented."""
    def __init__(self, raw_data):
        __data = {}
        super(OpenmeshTx, self).__init__("OpenmeshTx", 0xB6, __data)


class ProvUnprovisionedReceived(EventPacket):
    """The node received an unprovisioned beacon.

    Parameters
    ----------
        uuid : uint8_t[16]
            UUID in the unprovisioned beacon.
        rssi : int8_t
            RSSI of the received unprovisioned beacon.
        gatt_supported : uint8_t
            Whether the unprovisioned device supports GATT provisioning.
        adv_addr_type : uint8_t
            The advertisement address type of the sender of the unprovisioned beacon.
        adv_addr : uint8_t[6]
            The advertisement address of the sender of the unprovisioned beacon.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["uuid"] = raw_data[0:16]
        __data["rssi"], = struct.unpack("<b", raw_data[16:17])
        __data["gatt_supported"], = struct.unpack("<B", raw_data[17:18])
        __data["adv_addr_type"], = struct.unpack("<B", raw_data[18:19])
        __data["adv_addr"] = raw_data[19:25]
        super(ProvUnprovisionedReceived, self).__init__("ProvUnprovisionedReceived", 0xC0, __data)


class ProvLinkEstablished(EventPacket):
    """The given provisioning link has been established.

    Parameters
    ----------
        context_id : uint8_t
            Context ID of the established link.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["context_id"], = struct.unpack("<B", raw_data[0:1])
        super(ProvLinkEstablished, self).__init__("ProvLinkEstablished", 0xC1, __data)


class ProvLinkClosed(EventPacket):
    """The given provisioning link has been closed.

    Parameters
    ----------
        context_id : uint8_t
            Context ID of the closed link.
        close_reason : uint8_t
            Reason for closing the link.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["context_id"], = struct.unpack("<B", raw_data[0:1])
        __data["close_reason"], = struct.unpack("<B", raw_data[1:2])
        super(ProvLinkClosed, self).__init__("ProvLinkClosed", 0xC2, __data)


class ProvCapsReceived(EventPacket):
    """The device received provisioning capabilities on the provisioning link with the given
    context ID.

    Parameters
    ----------
        context_id : uint8_t
            Context ID of the link the capabilities were received on.
        num_elements : uint8_t
            The number of elements on the unprovisoined device.
        public_key_type : uint8_t
            The public key type used for the provisioning session.
        static_oob_types : uint8_t
            The available static OOB authentication methods.
        output_oob_size : uint8_t
            Maximum size of the output OOB supported.
        output_oob_actions : uint16_t
            Available OOB output actions.
        input_oob_size : uint8_t
            Maximum size of the input OOB supported.
        input_oob_actions : uint16_t
            Available OOB input actions.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["context_id"], = struct.unpack("<B", raw_data[0:1])
        __data["num_elements"], = struct.unpack("<B", raw_data[1:2])
        __data["public_key_type"], = struct.unpack("<B", raw_data[2:3])
        __data["static_oob_types"], = struct.unpack("<B", raw_data[3:4])
        __data["output_oob_size"], = struct.unpack("<B", raw_data[4:5])
        __data["output_oob_actions"], = struct.unpack("<H", raw_data[5:7])
        __data["input_oob_size"], = struct.unpack("<B", raw_data[7:8])
        __data["input_oob_actions"], = struct.unpack("<H", raw_data[8:10])
        super(ProvCapsReceived, self).__init__("ProvCapsReceived", 0xC3, __data)


class ProvInviteReceived(EventPacket):
    """The device received provisioning invite, so it can start identifying itself using any
    means it can.

    Parameters
    ----------
        context_id : uint8_t
            Context ID of the provisioning link.
        attention_duration_s : uint8_t
            Time in seconds during which the device will identify itself using any means it can.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["context_id"], = struct.unpack("<B", raw_data[0:1])
        __data["attention_duration_s"], = struct.unpack("<B", raw_data[1:2])
        super(ProvInviteReceived, self).__init__("ProvInviteReceived", 0xC4, __data)


class ProvStartReceived(EventPacket):
    """The device received provisioning start meaning that the provisioning process has been
    started and will stop identifying itself.

    Parameters
    ----------
        context_id : uint8_t
            Context ID of the provisioning link.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["context_id"], = struct.unpack("<B", raw_data[0:1])
        super(ProvStartReceived, self).__init__("ProvStartReceived", 0xCA, __data)


class ProvComplete(EventPacket):
    """The provisioning process was successfully completed.

    Parameters
    ----------
        context_id : uint8_t
            Context ID of the completed provisioning link.
        iv_index : uint32_t
            IV index for the network.
        net_key_index : uint16_t
            Network key index.
        address : uint16_t
            Unicast address for the device.
        iv_update_flag : uint8_t
            IV update in progress flag.
        key_refresh_flag : uint8_t
            Key refresh in progress flag.
        device_key : uint8_t[16]
            The device key of the provisioned device.
        net_key : uint8_t[16]
            The network key of the provisioned device.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["context_id"], = struct.unpack("<B", raw_data[0:1])
        __data["iv_index"], = struct.unpack("<I", raw_data[1:5])
        __data["net_key_index"], = struct.unpack("<H", raw_data[5:7])
        __data["address"], = struct.unpack("<H", raw_data[7:9])
        __data["iv_update_flag"], = struct.unpack("<B", raw_data[9:10])
        __data["key_refresh_flag"], = struct.unpack("<B", raw_data[10:11])
        __data["device_key"] = raw_data[11:27]
        __data["net_key"] = raw_data[27:43]
        super(ProvComplete, self).__init__("ProvComplete", 0xC5, __data)


class ProvAuthRequest(EventPacket):
    """Static authentication data is required to continue.

    Parameters
    ----------
        context_id : uint8_t
            Context ID of the link the authorization request appeared on.
        method : uint8_t
            Method of authentication requested.
        action : uint8_t
            Authentication action.
        size : uint8_t
            Authentication size.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["context_id"], = struct.unpack("<B", raw_data[0:1])
        __data["method"], = struct.unpack("<B", raw_data[1:2])
        __data["action"], = struct.unpack("<B", raw_data[2:3])
        __data["size"], = struct.unpack("<B", raw_data[3:4])
        super(ProvAuthRequest, self).__init__("ProvAuthRequest", 0xC6, __data)


class ProvEcdhRequest(EventPacket):
    """An ECDH shared secret must be calculated.

    Parameters
    ----------
        context_id : uint8_t
            Context ID of the link the ECDH request appeared on.
        peer_public : uint8_t[64]
            ECDH public key.
        node_private : uint8_t[32]
            ECDH private key.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["context_id"], = struct.unpack("<B", raw_data[0:1])
        __data["peer_public"] = raw_data[1:65]
        __data["node_private"] = raw_data[65:97]
        super(ProvEcdhRequest, self).__init__("ProvEcdhRequest", 0xC7, __data)


class ProvOutputRequest(EventPacket):
    """The device is required to do an action the user can recognize and use for authentication.

    Parameters
    ----------
        context_id : uint8_t
            Context ID of the link the output request appeared on.
        output_action : uint8_t
            Output action requested.
        data : uint8_t[16]
            Data for the output request.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["context_id"], = struct.unpack("<B", raw_data[0:1])
        __data["output_action"], = struct.unpack("<B", raw_data[1:2])
        __data["data"] = raw_data[2:]
        super(ProvOutputRequest, self).__init__("ProvOutputRequest", 0xC8, __data)


class ProvFailed(EventPacket):
    """The provisioning procedure failed.

    Parameters
    ----------
        context_id : uint8_t
            Context ID of the link the error happened on.
        error_code : uint8_t
            Provisioning error code.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["context_id"], = struct.unpack("<B", raw_data[0:1])
        __data["error_code"], = struct.unpack("<B", raw_data[1:2])
        super(ProvFailed, self).__init__("ProvFailed", 0xC9, __data)


class MeshMessageReceivedUnicast(EventPacket):
    """The mesh framework received a message matching a registered local unicast address, with
    the given parameters and data.

    Parameters
    ----------
        src : uint16_t
            Source address of the received packet.
        dst : uint16_t
            Destination unicast address or subscription handle.
        appkey_handle : uint16_t
            Handle of the application the message was received on.
        subnet_handle : uint16_t
            Handle of the subnetwork the message was received on.
        ttl : uint8_t
            Packet time to live value when first received.
        adv_addr_type : uint8_t
            Advertisement address type of the last hop sender.
        adv_addr : uint8_t[6]
            Advertisement address of the last hop sender.
        rssi : int8_t
            RSSI value of the message when received.
        actual_length : uint16_t
            Length of the received message, may be larger than the data reported if @ref
            SERIAL_EVT_MESH_MESSAGE_RECEIVED_DATA_MAXLEN is not big enough.
        data : uint8_t[235]
            Data payload of the packet.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["src"], = struct.unpack("<H", raw_data[0:2])
        __data["dst"], = struct.unpack("<H", raw_data[2:4])
        __data["appkey_handle"], = struct.unpack("<H", raw_data[4:6])
        __data["subnet_handle"], = struct.unpack("<H", raw_data[6:8])
        __data["ttl"], = struct.unpack("<B", raw_data[8:9])
        __data["adv_addr_type"], = struct.unpack("<B", raw_data[9:10])
        __data["adv_addr"] = raw_data[10:16]
        __data["rssi"], = struct.unpack("<b", raw_data[16:17])
        __data["actual_length"], = struct.unpack("<H", raw_data[17:19])
        __data["data"] = raw_data[19:]
        super(MeshMessageReceivedUnicast, self).__init__("MeshMessageReceivedUnicast", 0xD0, __data)


class MeshMessageReceivedSubscription(EventPacket):
    """The mesh framework received a message matching one of the registered subscription
    addresses, with the given parameters and data.

    Parameters
    ----------
        src : uint16_t
            Source address of the received packet.
        dst : uint16_t
            Destination unicast address or subscription handle.
        appkey_handle : uint16_t
            Handle of the application the message was received on.
        subnet_handle : uint16_t
            Handle of the subnetwork the message was received on.
        ttl : uint8_t
            Packet time to live value when first received.
        adv_addr_type : uint8_t
            Advertisement address type of the last hop sender.
        adv_addr : uint8_t[6]
            Advertisement address of the last hop sender.
        rssi : int8_t
            RSSI value of the message when received.
        actual_length : uint16_t
            Length of the received message, may be larger than the data reported if @ref
            SERIAL_EVT_MESH_MESSAGE_RECEIVED_DATA_MAXLEN is not big enough.
        data : uint8_t[235]
            Data payload of the packet.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["src"], = struct.unpack("<H", raw_data[0:2])
        __data["dst"], = struct.unpack("<H", raw_data[2:4])
        __data["appkey_handle"], = struct.unpack("<H", raw_data[4:6])
        __data["subnet_handle"], = struct.unpack("<H", raw_data[6:8])
        __data["ttl"], = struct.unpack("<B", raw_data[8:9])
        __data["adv_addr_type"], = struct.unpack("<B", raw_data[9:10])
        __data["adv_addr"] = raw_data[10:16]
        __data["rssi"], = struct.unpack("<b", raw_data[16:17])
        __data["actual_length"], = struct.unpack("<H", raw_data[17:19])
        __data["data"] = raw_data[19:]
        super(MeshMessageReceivedSubscription, self).__init__("MeshMessageReceivedSubscription", 0xD1, __data)


class MeshTxComplete(EventPacket):
    """A radio packet TX has completed.

    Parameters
    ----------
        token : nrf_mesh_tx_token_t
            TX token for the completed packet.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["token"], = struct.unpack("<I", raw_data[0:4])
        super(MeshTxComplete, self).__init__("MeshTxComplete", 0xD2, __data)


class MeshIvUpdateNotification(EventPacket):
    """The IV update procedure has been triggered for the network with the given index.

    Parameters
    ----------
        iv_index : uint32_t
            IV index updated to.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["iv_index"], = struct.unpack("<I", raw_data[0:4])
        super(MeshIvUpdateNotification, self).__init__("MeshIvUpdateNotification", 0xD3, __data)


class MeshKeyRefreshNotification(EventPacket):
    """A network has entered a new phase in the key refresh procedure.

    Parameters
    ----------
        netkey_index : uint16_t
            Network key index of the network key being updated.
        phase : uint8_t
            Current key refresh phase for the network key being updated.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["netkey_index"], = struct.unpack("<H", raw_data[0:2])
        __data["phase"], = struct.unpack("<B", raw_data[2:3])
        super(MeshKeyRefreshNotification, self).__init__("MeshKeyRefreshNotification", 0xD4, __data)


class MeshHeartbeatReceived(EventPacket):
    """A heartbeat message has been received.

    Parameters
    ----------
        init_ttl : uint8_t
            Initial TTL value used for sending this heartbeat message.
        hops : uint8_t
            Calculated hop value. Number of hops = Initial TTL - Received message TTL + 1.
        features : uint16_t
            Feature's state bitmap. See @ref MESH_DEFINES_HEARTBEAT to interpret bit fields.
        src : uint16_t
            Source address for the received heartbeat message.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["init_ttl"], = struct.unpack("<B", raw_data[0:1])
        __data["hops"], = struct.unpack("<B", raw_data[1:2])
        __data["features"], = struct.unpack("<H", raw_data[2:4])
        __data["src"], = struct.unpack("<H", raw_data[4:6])
        super(MeshHeartbeatReceived, self).__init__("MeshHeartbeatReceived", 0xD8, __data)


class MeshIvEntrySetNotification(EventPacket):
    """An IV entry has been set.

    Parameters
    ------------
        iv_index : uint32_t
            The current IV index.
        iv_update_in_progress : uint8_t
            Value indiciting the phase of the IV update process.
        iv_update_timeout_counter : uint16_t
            Timeout counter for IV update process.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["iv_index"], = struct.unpack("<I", raw_data[0:4])
        __data["iv_update_in_progress"], = struct.unpack("<B", raw_data[4:5])
        __data["iv_update_timeout_counter"], = struct.unpack("<H", raw_data[5:7])
        super(MeshIvEntrySetNotification, self).__init__("MeshIvEntrySetNotification", 0xD9, __data)


class MeshSeqnumEntrySetNotification(EventPacket):
    """An Sequence number block entry has been set.

    Parameters
    ------------
        next_block : uint32_t
            The next unallocated sequence number block.
    """
    def __init__(self, raw_data):
        __data = {}
        __data["next_block"], = struct.unpack("<I", raw_data[0:4])
        super(MeshSeqnumEntrySetNotification, self).__init__("MeshSeqnumEntrySetNotification", 0xDA, __data)


class MeshSarFailed(EventPacket):
    """A Mesh transmission of a SAR packet failed."""
    def __init__(self, raw_data):
        __data = {}
        super(MeshSarFailed, self).__init__("MeshSarFailed", 0xD7, __data)


class ModelSpecific(EventPacket):
    """An event generated by one of the initialized models.

    Parameters
    ----------
        model_evt_info : serial_evt_model_specific_header_t
            Contains the model id the event generates from and the model specific event type.
        data : uint8_t[249]
            Additional data provided by the event
    """
    def __init__(self, raw_data):
        __data = {}
        __data["model_evt_info"] = raw_data[0:5]
        __data["data"] = raw_data[5:]
        super(ModelSpecific, self).__init__("ModelSpecific", 0xF0, __data)


class Event(object):
    APPLICATION = 0x8A
    CMD_RSP = 0x84
    DEVICE_ECHO_RSP = 0x82
    DEVICE_INTERNAL_EVENT = 0x83
    DEVICE_STARTED = 0x81
    DFU_BANK_AVAILABLE = 0xA4
    DFU_END = 0xA3
    DFU_FIRMWARE_OUTDATED = 0xA5
    DFU_FIRMWARE_OUTDATED_NO_AUTH = 0xA6
    DFU_REQ_RELAY = 0xA0
    DFU_REQ_SOURCE = 0xA1
    DFU_START = 0xA2
    MESH_HEARTBEAT_RECEIVED = 0xD8
    MESH_IV_ENTRY_SET_NOTIFICATION = 0xD9
    MESH_IV_UPDATE_NOTIFICATION = 0xD3
    MESH_KEY_REFRESH_NOTIFICATION = 0xD4
    MESH_MESSAGE_RECEIVED_SUBSCRIPTION = 0xD1
    MESH_MESSAGE_RECEIVED_UNICAST = 0xD0
    MESH_SAR_FAILED = 0xD7
    MESH_SEQNUM_ENTRY_SET_NOTIFICATION = 0xDA
    MESH_TX_COMPLETE = 0xD2
    MODEL_SPECIFIC = 0xF0
    OPENMESH_CONFLICTING = 0xB5
    OPENMESH_NEW = 0xB3
    OPENMESH_TX = 0xB6
    OPENMESH_UPDATE = 0xB4
    PROV_AUTH_REQUEST = 0xC6
    PROV_CAPS_RECEIVED = 0xC3
    PROV_COMPLETE = 0xC5
    PROV_ECDH_REQUEST = 0xC7
    PROV_FAILED = 0xC9
    PROV_INVITE_RECEIVED = 0xC4
    PROV_LINK_CLOSED = 0xC2
    PROV_LINK_ESTABLISHED = 0xC1
    PROV_OUTPUT_REQUEST = 0xC8
    PROV_START_RECEIVED = 0xCA
    PROV_UNPROVISIONED_RECEIVED = 0xC0
    SAR_CONTINUE = 0x8C
    SAR_START = 0x8B


EVENT_LUT = {
    Event.APPLICATION: Application,
    Event.CMD_RSP: CmdRsp,
    Event.DEVICE_ECHO_RSP: DeviceEchoRsp,
    Event.DEVICE_INTERNAL_EVENT: DeviceInternalEvent,
    Event.DEVICE_STARTED: DeviceStarted,
    Event.DFU_BANK_AVAILABLE: DfuBankAvailable,
    Event.DFU_END: DfuEnd,
    Event.DFU_FIRMWARE_OUTDATED: DfuFirmwareOutdated,
    Event.DFU_FIRMWARE_OUTDATED_NO_AUTH: DfuFirmwareOutdatedNoAuth,
    Event.DFU_REQ_RELAY: DfuReqRelay,
    Event.DFU_REQ_SOURCE: DfuReqSource,
    Event.DFU_START: DfuStart,
    Event.MESH_HEARTBEAT_RECEIVED: MeshHeartbeatReceived,
    Event.MESH_IV_ENTRY_SET_NOTIFICATION: MeshIvEntrySetNotification,
    Event.MESH_IV_UPDATE_NOTIFICATION: MeshIvUpdateNotification,
    Event.MESH_KEY_REFRESH_NOTIFICATION: MeshKeyRefreshNotification,
    Event.MESH_MESSAGE_RECEIVED_SUBSCRIPTION: MeshMessageReceivedSubscription,
    Event.MESH_MESSAGE_RECEIVED_UNICAST: MeshMessageReceivedUnicast,
    Event.MESH_SAR_FAILED: MeshSarFailed,
    Event.MESH_SEQNUM_ENTRY_SET_NOTIFICATION: MeshSeqnumEntrySetNotification,
    Event.MESH_TX_COMPLETE: MeshTxComplete,
    Event.MODEL_SPECIFIC: ModelSpecific,
    Event.OPENMESH_CONFLICTING: OpenmeshConflicting,
    Event.OPENMESH_NEW: OpenmeshNew,
    Event.OPENMESH_TX: OpenmeshTx,
    Event.OPENMESH_UPDATE: OpenmeshUpdate,
    Event.PROV_AUTH_REQUEST: ProvAuthRequest,
    Event.PROV_CAPS_RECEIVED: ProvCapsReceived,
    Event.PROV_COMPLETE: ProvComplete,
    Event.PROV_ECDH_REQUEST: ProvEcdhRequest,
    Event.PROV_FAILED: ProvFailed,
    Event.PROV_INVITE_RECEIVED: ProvInviteReceived,
    Event.PROV_LINK_CLOSED: ProvLinkClosed,
    Event.PROV_LINK_ESTABLISHED: ProvLinkEstablished,
    Event.PROV_OUTPUT_REQUEST: ProvOutputRequest,
    Event.PROV_START_RECEIVED: ProvStartReceived,
    Event.PROV_UNPROVISIONED_RECEIVED: ProvUnprovisionedReceived,
    Event.SAR_CONTINUE: SarContinue,
    Event.SAR_START: SarStart
}


def event_deserialize(data):
    if not isinstance(data, bytearray):
        raise TypeError("Expected bytearray")

    if data[1] in EVENT_LUT:
        return EVENT_LUT[data[1]](data[2:])
    else:
        return None
